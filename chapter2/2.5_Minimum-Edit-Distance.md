## 2.5 最小编辑距离（*Minimum Edit Distance*）

自然语言处理的很多内容是关于测量两个字符串的相似度的。例如在拼写纠正（*spelling correction*）中，用户会输入一些错误的字符串，比如说 `graff`，而我们想知道用户真正想要输入的词是什么。用户可能是想输入一个与 `graffe` 相似的词。在候选的相似词中，`giraffe` 这个词与 `graffe` 只相差一个字母，从直觉上看，它似乎比 `grail` 和 `graf` 更接近 `graffe`，因为后者相差的字母更多。另一个例子来自于**共指**（*coreference*），即确定以下两个字符串是否指的是同一个实体的任务：

```
Stanford President Marc Tessier-Lavigne
Stanford University President Marc Tessier-Lavigne
```

同样，这两个字符串非常相似（只相差一个字），这似乎是确定它们可能指代同一实体（*might be coreferent*）的有用证据。

**编辑距离**（*Edit distance*）给我们提供了一种方法来量化这种字符串相似性。正式来说，两个字符串之间的**最小编辑距离**（*minimum edit distance*）被定义为将一个字符串转化为另一个字符串时所需的最小编辑操作次数（插入、删除、替换等操作）。

例如，*intention* 和 *execution* 之间的差距是 5（删除一个 `i`，用 `e` 代替 `n`，用 `x` 代替 `t`，插入 `c`，用 `u` 代替 `n`）。将两个字符串**对齐**（*alignment*），如图 2.14 所示，可视化字符串之间的距离，可以更容易地看到这一点。给定两个序列，**对齐**就是两个序列的子串之间的对应关系。因此，我们说 `I` 与一个空字符串对齐，`N` 与 `E` 对齐，以此类推。在对齐的字符串下面是另一种表示方式；一系列符号表示将上层字符串转换为下层字符串所需的**操作列表**（*operation list*）：**d** 表示删除，**s** 表示替换，**i** 表示插入。

![Fig 2.14](assets/fig2.14.png)

我们还可以为这些操作中的每一个操作分配一个特定的代价或权重。最简单的是 **Levenshtein** 距离，其中每一个操作的代价都是 1 (Levenshtein, 1966)[^1] —— 我们假设一个字母对其自身的替换的成本为 0，例如，`t` 对 `t` 的替换。*intention* 和 *execution* 之间的 Levenshtein 距离就是 5。 Levenshtein 还提出了这个度量标准的另一个版本，其中每个插入或删除的成本为 1，但不允许替换。（这相当于允许替换但其代价为 2，因为任何替换都可以用一个插入和一个删除来表示）。使用这个版本，*intention* 和 *execution* 之间的 Levenshtein 距离就是 8。

### 2.5.1 最小编辑距离算法（*The Minimum Edit Distance Algorithm*）

[^1]: Levenshtein, V. I. (1966). Binary codes capable of correcting deletions, insertions, and reversals. Cybernetics and Control Theory 10(8), 707–710. Original in Doklady Akademii Nauk SSSR 163(4): 845–848 (1965).
